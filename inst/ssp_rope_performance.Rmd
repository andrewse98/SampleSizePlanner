---
title: "rope_performance_test"
author: "Marton Kovacs"
date: "11/25/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
source("informedTtest_functions.R")
```

This document contains all the test that are carried out in order to improve the performance of the `ssp_rope` function.

# Parameters used for testing

```{r}
n1 = 314
band = 0.2
delta = 0
power = 0.1
alpha = .05
tol = 1e-4
granularity = 300
upper = 0.5
lower = 0.5
```

# Util functions

```{r}
# source("informedTtest_functions.R)
cdf_t <- function(x,
                  t,
                  n1,
                  n2 = NULL,
                  independentSamples = FALSE,
                  prior.location,
                  prior.scale,
                  prior.df,
                  rel.tol = .Machine$double.eps^0.25) {
  
  out <- integrate(posterior_t,
                   lower = -Inf, upper = x,
                   t = t, n1 = n1, n2 = n2,
                   independentSamples = independentSamples,
                   prior.location = prior.location,
                   prior.scale = prior.scale,
                   prior.df = prior.df,
                   rel.tol = rel.tol)$value
  
  # catch numerical errors
  if (out > 1 & out < 1.001) {
    out <- 1
    warning(
      "Numerical integration yields a CDF value slightly larger than 1. The CDF value has been replaced by 1.",
      call. = FALSE
    )
  }
  
  return(out)
  
}

# Vectorized cdf_t
v_cdf_t <- Vectorize(cdf_t)

# detect2 function
# This function works like purrr::map2 but with detect
detect2_index <- function(.x, .y, .f, .dir = c("forward", "backward")) {
  .dir <- rlang::arg_match(.dir, c("forward", "backward"))
  
  for (i in index(.x, .dir)) {
    if (.f(.x[[i]], .y[[i]])) {
      return(i)
    }
  }
  
  0L
}

index <- function(x, dir) {
  idx <- seq_along(x)
  if (dir == "backward") {
    idx <- rev(idx)
  }
  idx
}

calculate_and_check <- function (band, t, n1, tol, alpha) {
    upper = cdf_t (band, t, n1 = n1, n2 = n1, independentSamples = T, prior.location = 0, 
                   prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
    lower = cdf_t (-band, t, n1 = n1, n2 = n1, independentSamples = T, prior.location = 0, 
                   prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
    
    lower<(alpha/2) & upper>(1-alpha/2)
}

check <- function (upper, lower, alpha = .05) {
  lower<(alpha/2) & upper>(1-alpha/2)
}
```

# The original function

```{r}
rope <- function(n1, delta, band, alpha = .05, tol = 1e-4, granularity = 300) {
  n2 = n1
  t = seq(qt(.005, n1+n2-2, delta/sqrt(1/n1+1/n2)), 
          qt(.995, n1+n2-2, delta/sqrt(1/n1+1/n2)), length = granularity)
  upper = lower = 0.5
  i = 0
  while (!(lower<(alpha/2) & upper>(1-alpha/2))) {
    i = i+1
    upper = cdf_t(band, t[i], n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                  prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
    lower = cdf_t(-band, t[i], n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                  prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
  }
  upper = lower = 0.5
  j = length(t) + 1
  while (!(lower<(alpha/2) & upper>(1-alpha/2))) {
    j = j-1
    upper = cdf_t(band, t[j], n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                  prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
    lower = cdf_t(-band, t[j], n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                  prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
  }
  
  npower = pt(t[j], n1+n2-2, delta/sqrt(1/n1+1/n2)) - pt(t[i], n1+n2-2, delta/sqrt(1/n1+1/n2))
  
  cat ("\n n1 is ", n1, ", power is ", npower, sep = "")

}

rope(n1 = 314, band = 0.3, delta = 0)
```

# Profiling

```{r eval=FALSE}
profvis::profvis(rope(n1 = 314, delta = 0, band = 0.2))
```

# Fully vectorized version

```{r}
v_rope <- function (n1, delta, band, alpha = .05, tol = 1e-4, granularity = 300) {
    n2 = n1
    t = seq (qt (.005, n1+n2-2, delta/sqrt(1/n1+1/n2)), 
             qt (.995, n1+n2-2, delta/sqrt(1/n1+1/n2)), length = granularity)
    
    bound <- 
      list(
        Upper = v_cdf_t(band, t, n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                        prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol),
        Lower = v_cdf_t(-band, t, n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                        prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
        )
    
    i <- detect2_index(bound[["Upper"]], bound[["Lower"]], check, .dir = "forward")
    j <- detect2_index(bound[["Upper"]], bound[["Lower"]], check, .dir = "backward")
    
    npower = pt(t[j], n1+n2-2, delta/sqrt(1/n1+1/n2)) - pt(t[i], n1+n2-2, delta/sqrt(1/n1+1/n2))
    
    cat ("\n n1 is ", n1, ", power is ", npower, sep = "")
}

v_rope(n1 = 314, band = 0.3, delta = 0)
```

# Purrr version

```{r}
purrr_rope <- function (n1, band, delta, alpha = .05, tol = 1e-4, granularity = 300) {
    n2 = n1
    t = seq (qt (.005, n1+n2-2, delta/sqrt(1/n1+1/n2)), 
             qt (.995, n1+n2-2, delta/sqrt(1/n1+1/n2)), length = granularity)

    i <- purrr::detect(t, ~ calculate_and_check(n1 = n1, band = band, t = .x, tol = tol, alpha = alpha), .dir = "forward")
    j <- purrr::detect(t, ~ calculate_and_check(n1 = n1, band = band, t = .x, tol = tol, alpha = alpha), .dir = "backward")
    
    npower = pt(j, n1+n2-2, delta/sqrt(1/n1+1/n2)) - pt(i, n1+n2-2, delta/sqrt(1/n1+1/n2))
    
    cat ("\n n1 is ", n1, ", power is ", npower, sep = "")
}

purrr_rope(n1 = 314, band = 0.3, delta = 0)
```

# Rcpp version

```{r}
Rcpp::sourceCpp('rcpp_functions.cpp')
Rcpp::sourceCpp('rcpp_informed_ttest_functions.cpp')

integrate_exp4()

test <- my_qt(314, 0, 300)

original <- seq (qt (.005, 314+314-2, 0/sqrt(1/314+1/314)), 
             qt (.995, 314+314-2, 0/sqrt(1/314+1/314)), length = 300)

microbenchmark::microbenchmark(
  my_qt(314, 0, 300),
  seq (qt (.005, 314+314-2, 0/sqrt(1/314+1/314)), 
             qt (.995, 314+314-2, 0/sqrt(1/314+1/314)), length = 300),
  times = 10000
)

rcpp_rope <- function(n1, delta, band, alpha = .05, tol = 1e-4, granularity = 300) {
  n2 = n1
  t = my_qt(n1, delta, granularity)
  t = as.vector(t)
  upper = lower = 0.5
  i = 0
  while (!(lower<(alpha/2) & upper>(1-alpha/2))) {
    i = i+1
    upper = cdf_t(band, t[i], n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                  prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
    lower = cdf_t(-band, t[i], n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                  prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
  }
  upper = lower = 0.5
  j = length(t) + 1
  while (!(lower<(alpha/2) & upper>(1-alpha/2))) {
    j = j-1
    upper = cdf_t(band, t[j], n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                  prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
    lower = cdf_t(-band, t[j], n1 = n1, n2 = n2, independentSamples = T, prior.location = 0, 
                  prior.scale = 1/sqrt(2), prior.df = 1, rel.tol = tol)
  }
  
  npower = pt(t[j], n1+n2-2, delta/sqrt(1/n1+1/n2)) - pt(t[i], n1+n2-2, delta/sqrt(1/n1+1/n2))
  
  cat ("\n n1 is ", n1, ", power is ", npower, sep = "")

}
```

# Compare performance

```{r}
microbenchmark::microbenchmark(
    rope(n1 = 314, band = 0.3, delta = 0),
    # v_rope(314, 0.3, 0),
    # purrr_rope(n1 = 314, band = 0.3, delta = 0),
    rcpp_rope(n1 = 314, band = 0.3, delta = 0),
    times = 10
)  
```

